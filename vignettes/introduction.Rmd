---
title: "Introduction to VegetationAnalysisToolkit"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to VegetationAnalysisToolkit}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

Welcome to the VegetationAnalysisToolkit documentation! This guide will introduce you to the core philosophy and features of the package, and demonstrate how to use them effectively in your research projects.


<br>

# Basic use

## Installation

I recommend using R version 4.3.3 or later to ensure compatibility with all features of this package. While earlier versions of R (from 3.5.0 onward) might work, this package is developed and tested primarily on R 4.3.3. You can download the latest version from the [CRAN website](https://cran.r-project.org/).

To install the VegetationAnalysisToolkit package, follow the instructions provided in the [README file](https://github.com/anonymus06/VegetationAnalysisToolkit#installation) on GitHub.

## Setting Up the Project Directory

Before starting your analysis, it's important to set up the project directory. This can be done easily using the `setup_project_directory()` function that will automatically create the necessary folder structure to organize your data, scripts, and outputs efficiently.

```{r, eval = FALSE, message = FALSE}
setup_project_directory()
```

Running this function creates a project directory with the following structure:

```{r, echo = FALSE, message=FALSE}
cat("
├── data/                      # Contains data files (raw data files and user made index files)
│   └── sample/                # Contains example project data
│       ├── chlorophyl/        # Includes chlorophyll-related data files
│       │   ├── 23101812.CSV
│       │   └── index.xlsx
│       └── ndvi/              # Includes NDVI-related data files
│       │   ├── index.xlsx
│       │   └── plantpen_NDVI_231018.txt
│       └── config.txt         # Example configuration file used in analysis
├── docs/                      # Stores documentation files related to the project
│   ├── introduction.html
│   ├── introduction.R
│   └── introduction.Rmd
├── examples/                  # Contains example scripts demonstrating basic usage of the toolkit
│   └── example_script.R
├── main.R                     # The main script file where you can start typing your analysis commands
├── outputs/                   # Use this folder to store the results of your analyses
└── README.txt                 # Provides an overview of the project and instructions for starting
")
```


## Project Data Management Guidelines

This section provides guidelines on structuring and naming your input data files, along with best practices for organizing and managing measurement data using the Vegetation Analysis Toolkit. The earlier directory structure example should serve as a blueprint for your project.

### Raw Data Files
Each dataset folder (as shown in the file structure) must contain one index file and one or more uniquely named data files that store raw measurement data. These data files are transferred directly from the instruments without any corrections or edits.

* **MC-100 Chlorophyll Concentration Meter:** This instrument generates data in CSV format. The data files should be named with the exact date in the format YYMMDDHH or YYMMDD. Optionally, additional text can be included in the filename, but it is recommended to adhere to the date format to avoid issues, as demonstrated in the sample file structure.

* **PlantPen NDVI & PRI:** This instrument generates data in text format (.txt). The data processing does not depend on a specific naming convention for these files; any filename can be used as long as the content is correct. The original filenames generated by the instrument can be kept unchanged.

### Index Files
For all index files, the filename should simply be _index.xlsx_.

The index files serve as a reference that links the raw measurement data to specific measurement points recorded by the user during data collection. Each index file includes a series of identifier codes found in the data files and their corresponding measurement point codes (referenced as _description_ in the index files), which are manually noted by the user during the measurement process.

Within the index file, there are multiple sheets, each corresponding to a specific measurement date. These sheets should be named according to the date of the measurement. The index column in the data files contains the measurement identifier, while the description column contains the corresponding measurement point code.

### Date Handling
The dates recorded by the instruments may occasionally be inaccurate. To ensure consistency, the dates used in data processing will be derived from the manually assigned dates in the file names of both the data files and the sheets within the index files. 

Therefore, it is **crucial to accurately specify the date** when: <br>
\- Naming the raw data files (for the MC-100 Chlorophyll Concentration Meter). <br>
\- Creating the sheets within the index files.

---

By following these guidelines, you ensure that your data is accurately organized and ready for analysis using the VegetationAnalysisToolkit.


## How it works

Let’s discuss some of the key features available in the functions of the VegetationAnalysisToolkit package.

### Data Validation Checks
Data integrity is crucial for accurate analysis. The `check_data()` function (currently in a demo version, embedded only within the `process_PlantPen_NDVI_PRI()`) automatically validates your data against several criteria to ensure it is ready for analysis. To activate this validation, make sure to set the `validate` argument to `TRUE` when using these processing functions.

For example, when calling `process_PlantPen_NDVI_PRI()`, you would specify:

```{r, eval = FALSE}
process_PlantPen_NDVI_PRI(
 folder_path, 
 output,
 lower_limit,
 upper_limit,
 variable,
 validate=TRUE,
 split_code
 )
```


Below is a table summarizing the validation checks performed by the package:


| Validation Check                     | Description                                                               |
|--------------------------------------|---------------------------------------------------------------------------|
| Data Existence (Empty File Check)    | Ensures that the input file is not completely empty.                      |
| Data Existence (Loaded Data Check)   | Verifies that the data frame contains data after loading.                 |
| Column Names Mismatch                | Ensures that the column names in the input file match the expected format.|
| Data Types Mismatch                  | Validates that the data types of each column match the expected types.    |
| Non-Sequential Index                 | Checks that index values are sequential and do not have unexpected gaps.  |
| Incorrect Date-Time Format           | Ensures that date and time columns follow the correct format.             |
| ID/Unit Consistency                  | Validates that ID and unit codes are consistent throughout the dataset.   |
| Missing Values                       | Identifies any missing values in critical columns.                        |
| Duplicate Rows                       | Detects and flags duplicate entries in the dataset.                       |


### Data Filtering
The `process_PlantPen_NDVI_PRI()` and `process_MC100_Chlorophyll()` functions allow you to filter out irrelevant or extreme data points by setting the `lower_limit` and `upper_limit` parameters. These parameters define the range of values that will be included in the analysis:

\- `lower_limit`: This sets the minimum threshold for the data. Any data points below this value will be excluded from the analysis. <br>
\- `upper_limit`: This sets the maximum threshold for the data. Any data points above this value will be excluded from the analysis.

For example, if you want to exclude NDVI values that are below 0.2 or above 0.8, you would set `lower_limit = 0.2` and `upper_limit = 0.8` . This ensures that only data within this range is processed, making your analysis more focused and reliable.

```{r, eval = FALSE}
process_PlantPen_NDVI_PRI(
 folder_path, 
 output,
 lower_limit = 0.2,
 upper_limit = 0.8,
 variable,
 validate,
 split_code
 )
```


### Split Code
The `split_code` functionality automatically breaks down the measurement point codes (referred to as _Code_ in the output files) into separate, meaningful columns. This optional feature is especially useful when collecting data across multiple locations or under varying conditions, allowing you to analyze your dataset in more granular detail.


**Without Split Code (Default):**
When `split_code = FALSE`, the dataset is processed as a single unit, with the Code left intact as a single string.

```
date        Code  NDVI
2020.01.01  CSTF  0.1
```


**With Split Code Enabled:**
Setting `split_code = TRUE` activates the data splitting logic defined in the _config.txt_ file. The Code string is split into its component parts (such as _Landuse_, _Position_, and _Interrow_), which are represented in separate columns.

```
date        Code   NDVI   Landuse   Position   Interrow
2020.01.01  CSTF   0.1    CST       F          S
```


**Logic Behind the Split:**
The _config_ file is designed to split the Code string into multiple components based on a set of predefined rules. In this dataset, two key factors are considered:

\- The geographical position of the measurement point (e.g., field, slope). <br>
\- The landuse at the measurement point (e.g., vineyard, forest).

These components help categorize the data more effectively, allowing for detailed analysis.


**Special Case: Vineyard Landuse** <br>
For vineyard landuse, there’s an additional distinction between:

\- In-row measurements: taken directly at the vine trunks. <br>
\- Inter-row measurements: taken between the rows of grapevines.

This distinction is managed by the _Interrow_ parameter, which specifies whether the measurement was in-row or inter-row in the output.


**Example Usage of Codes:**
Let’s say you want to analyze NDVI data for different positions and landuses, splitting the data accordingly. The config.txt file will guide the script on how to interpret the codes in the description columns from your data.

For example, consider the code CSTASK:

\- CST: Represents the land use (e.g., vineyard). <br>
\- A: Represents the position (e.g., slope). <br>
\- SK: Represents the inter-row condition (e.g., between the rows).

Note: Only the inter-row code (SK) is present in the input data as part of the Code. The in-row condition (S) is not included in the input Code because it's treated as the default condition. For example, the code will never appear as CSTAS; instead, CSTASK refers to an inter-row measurement.


**Code Breakdown Example:**
The Code is an abbreviation that combines multiple elements (landuse, position, interrow) into one string. These are then split into distinct columns for clearer analysis.

Example config.txt:
```
# Position
F|A|AHP

# Landuse
CST|CSR|CSU|E|R

# Interrow Condition for Specific Landuse
CST|CSR|CSU

# Default Interrow code - In-row code
S

# Alternative Interrow code - Inter-row code
SK
```


**Explanation:** <br>
\- Position: Specifies possible positions for measurements. <br>
\- Landuse: Lists all codes representing different land uses (e.g., grassland, arable land, etc.). <br>
\- Interrow Condition: Defines the landuse codes where inter-row measurements apply (e.g., vineyards). <br>
\- In-row code: The default condition for measurements taken directly at the vine trunks; this is not included in the Code string. <br>
\- Inter-row code: The code representing inter-row measurements in the output data, such as measurements taken between the rows.

When `split_code = TRUE`, the script will reference the config.txt file to properly segment the data based on these codes, creating separate columns for land use, position, and interrow conditions.

Example usage of this feature: 
```{r, eval = FALSE}
process_PlantPen_NDVI_PRI(
 folder_path, 
 output,
 lower_limit,
 upper_limit,
 variable,
 validate,
 split_code = TRUE
 )
```


### Variable Name
The `variable` parameter specifies which measurement you want to process. This package supports multiple variables depending on the device used for data collection. However, it has only been optimized and tested for specific variables, as detailed below.

* **MC-100 Chlorophyll Concentration Meter** (for more detailed documentation, [see](https://www.apogeeinstruments.com/mc-100-chlorophyll-concentration-meter/)):
   
   The MC-100 can measure chlorophyll content in two units (and their subsequent data files' codes):
    - Relative chlorophyll content (CCI),
    - Actual chlorophyll concentration (see the list).
   
   Tested Variables:
    - CCI: Chlorophyll Content Index (relative chlorophyll content).
    
   Test Modes:
    - 1 point no averaging
    - Multi-point average
    - Multi-point std dev
    
   Tested Modes:
    - 1 point no averaging

Note: Although the script is optimized for the "1 point no averaging" mode, it is expected to work with the other modes. However, adjustments may be needed for the naming and tackling of the structure of the input and output data. Similarly, although the package is created for CCI, it should handle data from other species and unit types without issue. The primary difference would be in the variable names, which correspond to the specific species and options selected in the device's function menu.
 
 
* **PlantPen NDVI & PRI** (for full documentation, [see](https://psi.cz/support/downloads/hd001/pppri001/)): 

   It measures relative chlorophyll content through 2 indices of its standard PlantPen versions:
    - Photochemical Reflectance Index (PRI),
    - Normalized Difference Vegetation Index (NDVI)
    
    Tested Variables:
    - NDVI
    
Note: While this package is optimized for processing NDVI data, it is expected to handle PRI data and other modes of measurement. Some modifications might be required for specific data formats or variable names.
  

You must specify the correct variable name in your function call to ensure the appropriate data is processed. The package is designed to handle these specific variables and apply the necessary calculations accordingly.

```{r, eval = FALSE}
process_PlantPen_NDVI_PRI(
 folder_path, 
 output,
 lower_limit,
 upper_limit,
 variable = "NDVI",
 validate,
 split_code
 )
```


---

For detailed examples and case studies on how to use these functions in practice, refer to the `/examples` folder included with the package. These examples demonstrate how to process data, visualize results, and validate datasets using the VegetationAnalysisToolkit.

For a comprehensive understanding of each function, including their arguments and options, you can access the full documentation within R. Simply use the help command with the desired function name and for more detailed explanations and examples, refer to the specific function documentation using `?function_name`:

```{r, eval = FALSE}
??process_PlantPen_NDVI_PRI
```

<br>

# Advanced use

## Version and Validity of Installations

To check the version of VegetationAnalysisToolkit currently in use, use the following command:

```{r, eval = FALSE}
VegetationAnalysisToolkit::version()
```

To ensure that all installed VegetationAnalysisToolkit packages are valid and up-to-date, run:

```{r, eval = FALSE}
VegetationAnalysisToolkit::valid()
```

This command will return an object listing any packages that are out-of-date or from unexpected versions. You can inspect these results to identify and update the necessary packages.


## Updating old packages

You can update all packages to their latest versions with:

```{r, eval = FALSE}
VegetationAnalysisToolkit::install()
```

If some packages are out-of-date, you might get a prompt asking which packages to update. You can choose to update all, some, or none of them.


## Changing version
To change the version of VegetationAnalysisToolkit, specify the desired version like this:

```{r, eval = FALSE}
VegetationAnalysisToolkit::install(version = "1.5")
```

This might require an updated version of R. If the selected version is incompatible with your R version, an error will be shown, and you'll need to install the correct version of R.


## Managing multiple versions {#multiple-versions}

It is possible to maintain multiple versions of VegetationAnalysisToolkit on the same computer. A best practice is to create a dedicated library for each version of the package you wish to use. This ensures that packages from different versions do not conflict with each other.

<br>

Step 1: Create a Directory for the Library

First, create a directory to store the library for the specific version of VegetationAnalysisToolkit you want to use. Replace `USER_NAME` with your actual username:

```
- Linux: `mkdir -p ~/R/R4.3-Veg-1.5.2`
- macOS: `mkdir -p ~/Library/R/R4.3-Veg-1.5.2/library`
- Windows: mkdir "C:\Users\USER_NAME\AppData\Local\R\win-library\R4.3-Veg-1.5.2"
```

<br>

Step 2: Set the Library Path

Next, set the `R_LIBS_USER` environment variable to point to the newly created directory and invoke R. This tells R to use this directory as the library path for installing and loading packages for this particular version of VegetationAnalysisToolkit.

```
- Linux: `R_LIBS_USER=~/R/R4.3-Veg-1.5.2 R`
- macOS: `R_LIBS_USER=~/Library/R/R4.3-Veg-1.5.2/library R`
- Windows: `cmd /C "set R_LIBS_USER=C:\Users\USER_NAME\AppData\Local\R\win-library\R4.3-Veg-1.5.2 && R"`
```

You can temporarily set the library path within an R session using the following command:
```{r, eval = FALSE}
.libPaths("~/win-library/R4.3-Veg-1.5.2")
```
This changes the library location for that session. All packages installed or loaded during this session will come from or go to that specific folder.

To make this change permanent (so that every time you open R, it automatically uses this path), you would need to modify your R environment settings file (`.Renviron`) or adjust system-wide environment variables.

<br>

Step 3: Verify the Library Path in R

Once you have set the library path, you can verify it in R to ensure it is correctly configured:
```{r, eval=FALSE}
.libPaths()
```

```
[1] "C:/Users/USER_NAME/AppData/Local/R/win-library/R4.3-Veg-1.5.2 R"
[2] "C:/Program Files/R/R-4.3.3/library"
```

This command will show the paths where R is looking for packages. The newly set path should appear at the top of the list.


## Function structure (for developers)

You can create a visual representation of the function structure to better understand the code and it works:

```{r, eval = FALSE}
library(pkgnet)
CreatePackageReport("VegetationAnalysisToolkit")
```

## Session information

```{r, eval = TRUE}
sessionInfo()
```
