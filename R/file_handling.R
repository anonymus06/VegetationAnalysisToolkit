#' Functions for handling file reading and processing.


#' Read NDVI Data with Index files

#' @param folder_pathway The path to the folder containing NDVI data and its index files.
#' @param skip_rows The number of rows to skip when reading the data files. Default is 4.
#' @param valid_patterns A character vector of valid filename patterns to match. Default is c("plantpen_NDVI_\\d{6}\\.txt$", "index\\.xlsx$").
#'
#' @return A list containing:
#'         - `all_data`: A list of data frames containing NDVI data and index files, organized by file name or sheet name.
#'         - `data_frame_files`: A list mapping data frame names to their respective file paths.
#'
#' @details This function was optimized to read NDVI raw text files generated by instrument X (version Y)
#' and user-defined Excel files that record measurements. For text files, it assumes a specific format
#' (tab-separated values) but includes a provision for handling files with varying structures through potential
#' future enhancements.
#'
#' @importFrom openxlsx getSheetNames loadWorkbook read.xlsx
#' @importFrom utils read.table
read_NDVI <- function(folder_pathway, env,
                      skip_rows = 4,
                      valid_patterns = c("plantpen_NDVI_\\d{6}\\.txt$", "index\\.xlsx$")) {
 # List all the files in the directory with their paths
 files <- list.files(folder_pathway, full.names = TRUE)

 # Initialize lists to store data and file mappings
 all_data <- list()
 data_frame_files <- list()

 # Process each file in the directory
 process_file <- function(file) {
  # Determine the file extension and handle accordingly
  file_extension <- tools::file_ext(file)


  # Check if the file is a directory
  if (is_directory(file)) {
   log_skipped_file(file, "folder", env)
   return(NULL)
  }

  # Check if the file name matches the valid patterns
  if (!check_naming_pattern(file, valid_patterns)) {
   log_issue(file, "Invalid naming pattern")
   return(NULL)
  }

  # Handle Excel files (NDVI index files)
  if (file_extension == "xlsx" && !startsWith(basename(file), "~$")) {
   return(handle_excel_file(file))

   # Handle text files (NDVI data files)
  } else if (file_extension == "txt" && !startsWith(basename(file), "~$")) {
   return(handle_text_file(file, skip_rows, env))

   # Skip temporary files (to avoid duplicates)
  } else if (startsWith(basename(file), "~$")) {
   log_skipped_file(file, "temporary file", env)
   return(NULL)

   # Log any other skipped files for user awareness
  } else {
   log_skipped_file(file, "element", env)
   return(NULL)
  }
 }

 # Loop through each file and process
 results <- lapply(files, process_file)

 # Combine results
 for (result in results) {
  if (!is.null(result)) {
   all_data <- c(all_data, result$data)
   data_frame_files <- c(data_frame_files, result$files)
  }
 }

 # Return the list of data and file mappings
 return(list(all_data = all_data, data_frame_files = data_frame_files))
}

#' Read Chlorophyll Data with Index files

#' @param folder_pathway A character string specifying the path to the folder containing the chlorophyll data files.
#' @param valid_patterns A character vector of valid filename patterns to match. Default is c("^\\d{6}(\\d{8})?\\.csv$", "index\\.xlsx$").
#'
#' @return A list containing:
#'         - `all_data`: A list of data frames containing chlorophyll data and index files, organized by file name or sheet name.
#'         - `data_frame_files`: A list mapping data frame names to their respective file paths.
#'
#' @details This function was optimized to read chlorophyll raw CSV files generated by instrument X (version Y)
#' and user-defined Excel files that record measurements. For sample file, see: .
#'
#' @importFrom openxlsx getSheetNames loadWorkbook read.xlsx
#' @importFrom utils read.csv
read_Chlorophyll <- function(folder_pathway,
                             valid_patterns = c("^\\d{6}(\\d{8})?\\.csv$", "index\\.xlsx$")) {
 # List all the files in the directory with their paths
 files <- list.files(folder_pathway, full.names = TRUE)

 # Initialize lists to store data and file mappings
 all_data <- list()
 data_frame_files <- list()

 # Process each file in the directory
 process_file <- function(file) {
  # Determine the file extension and handle accordingly
  file_extension <- tools::file_ext(file)


  # Check if the file is a directory
  if (is_directory(file)) {
   log_skipped_file(file, "folder")
   return(NULL)
  }

  # Check if the file name matches the valid patterns
  if (!check_naming_pattern(file, valid_patterns)) {
   log_issue(file, "Invalid naming pattern")
   return(NULL)
  }

  # Handle Excel files (Chlorophyl index files)
  if (file_extension == "xlsx" && !startsWith(basename(file), "~$")) {
   return(handle_excel_file(file))

   # Handle CSV files (Chlorophyl data files)
  } else if (file_extension == "CSV" && !startsWith(basename(file), "~$")) {
   return(handle_CSV_file(file))

   # Skip temporary files (to avoid duplicates)
  } else if (startsWith(basename(file), "~$")) {
   log_skipped_file(file, "temporary file")
   return(NULL)

   # Log any other skipped files for user awareness
  } else {
   log_skipped_file(file, "element")
   return(NULL)
  }
 }

 # Loop through each file and process
 results <- lapply(files, process_file)

 # Combine results
 for (result in results) {
  if (!is.null(result)) {
   all_data <- c(all_data, result$data)
   data_frame_files <- c(data_frame_files, result$files)
  }
 }

 # Return the list of data and file mappings
 return(list(all_data = all_data, data_frame_files = data_frame_files))
}

#' Log skipped files
#'
#' @param file The file that was skipped.
#' @param reason The reason why the file was skipped.
log_skipped_file <- function(file, reason, env) {
 # cat("Skipped", reason, "from reading:", file, "\n")
 # messages <- add_message(messages, paste("Skipped", reason, "from reading:", file), "info")
 add_message(env, paste("Skipped", reason, "from reading:", file), "info")

}

#' Check naming pattern
#'
#' @param file The file to check.
#' @param valid_patterns A character vector of valid filename patterns.
#'
#' @return TRUE if the file name matches any of the valid patterns, FALSE otherwise.
check_naming_pattern <- function(file, valid_patterns) {
 any(sapply(valid_patterns, function(pattern) grepl(pattern, basename(file))))
}

#' Handle Excel files
#'
#' @param file The Excel file to read.
#'
#' @return A list containing:
#'         - `data`: A list of data frames for each sheet in the Excel file.
#'         - `files`: A list mapping sheet names to the file path.
handle_excel_file <- function(file) {
 sheets <- getSheetNames(file) # Get sheet names from the workbook
 wb <- loadWorkbook(file) # Load the workbook
 sheet_data <- lapply(sheets, function(sheet) { # Read each sheet into a list element, indexed by sheet name
  read.xlsx(wb, sheet = sheet, startRow = 1)
 })
 names(sheet_data) <- sheets
 list(data = sheet_data, files = setNames(rep(file, length(sheets)), sheets))
}

#' Handle text files
#'
#' @param file The text file to read.
#' @param skip_rows The number of rows to skip when reading the text file. Default is 4.
#'
#' @return A list containing:
#'         - `data`: A list with the data frame of the text file.
#'         - `files`: A list mapping the file name to the file path.
# handle_text_file <- function(file, skip_rows = 4) {
#  sheet_data <- read.table(file, header = TRUE, sep = "\t", skip = skip_rows)
#  data <- list()
#  files <- list()
#  data[[basename(file)]] <- sheet_data
#  files[[basename(file)]] <- file
#  list(data = data, files = files)
# }
handle_text_file <- function(file, skip_rows = 4, env) {
 # cat(sprintf("Attempting to read text file: %s with skip_rows = %d\n", file, skip_rows))

 # Initialize lists to store data and file mappings
 data <- list()
 files <- list()

 tryCatch({
  sheet_data <- read.table(file, header = TRUE, sep = "\t", skip = 4)

  #todo: incroporate with error log! , állítsa is le a futást!
  # befejez a többi todo-t amit a fuggvenyekbe irtam s felulirtam az elozoket de nem mentettem le
  # if (is.null(sheet_data)) {
  #  # stop("The data frame does not exist or is NULL.")
  # add_message(env, "The data frame does not exist or is NULL.", "issues")
  # return(NULL)
  # local_issues <-
  #  add_issue(local_issues,
  #            name,
  #            paste0("The data frame '", name, "' does not exist or is NULL. Source file: '", file_name, "'"))
  # }

  data[[basename(file)]] <- sheet_data
  files[[basename(file)]] <- file
  # cat(sprintf("Successfully read file: %s\n", file))

 }, error = function(e) {
  # cat(sprintf("Error reading file: %s - %s\n", file, e$message))
  data[[basename(file)]] <- NULL
  files[[basename(file)]] <- file
  if (is.null(data[[basename(file)]])) {
   add_message(env, "The data frame does not exist or is NULL.", "issues")
   # stop("The data frame does not exist or is NULL.")
  }
 })

 list(data = data, files = files)
}

#' Handle CSV files
#'
#' @param file The CSV file to read.
#'
#' @return A list containing:
#'         - `data`: A list with the data frame of the CSV file.
#'         - `files`: A list mapping the file name to the file path.
handle_CSV_file <- function(file) {
 sheets <- read.csv(file, sep = ";", header = TRUE, encoding = "UTF-8", check.names = FALSE)
 data <- list()
 files <- list()
 data[[basename(file)]] <- sheet_data
 files[[basename(file)]] <- file
 list(data = data, files = files)
}

# Function to read the simple configuration file
readSimpleConfig <- function(file) {
 lines <- readLines(file)
 config <- list(
  positionPattern = lines[1],
  landusePattern = lines[2]
 )

 if (tolower(lines[3]) != "na") {
  landuse_patterns <- unlist(strsplit(lines[3], "|", fixed = TRUE))
  interRowConditions <- lapply(landuse_patterns, function(pat) {
   # list(pattern = paste0("\\b", pat, "\\b"), default = lines[4], extract = lines[5])
   list(pattern = pat, default = lines[4], extract = lines[5])
  })
  config$interRowConditions <- interRowConditions
 } else {
  config$interRowConditions <- NULL
 }

 return(config)
}
